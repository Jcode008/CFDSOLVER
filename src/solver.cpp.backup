#include "solver.hpp"
#include <vector>
#include <cmath>
#include <algorithm>
#include <iostream>

// Constructor: initialize references and temporary arrays
Solver::Solver(Grid &g, Field &f, double r, double v, double dt_)
    : grid(g), field(f), rho(r), nu(v), dt(dt_)
{
    totalCells = static_cast<size_t>(grid.nx) * grid.ny;
    u_star.assign(totalCells, 0.0);
    v_star.assign(totalCells, 0.0);
}

void Solver::computeIntermediateVelocities() {
    const int nx = grid.nx;
    const int ny = grid.ny;

    // Initialize u_star and v_star to current field values first
    for (int i = 0; i < ny; ++i) {
        for (int j = 0; j < nx; ++j) {
            size_t id = idx(i, j);
            u_star[id] = field.u(i, j);
            v_star[id] = field.v(i, j);
        }
    }

    #pragma omp parallel for schedule(static)
    for (int i = 1; i < ny - 1; ++i) {
        for (int j = 1; j < nx - 1; ++j) {
            if (!grid.isFluid(i, j)) continue;

            size_t id = idx(i, j);
            double u_ij = field.u(i, j);
            double v_ij = field.v(i, j);

            // Check for existing NaNs in input
            if (std::isnan(u_ij) || std::isnan(v_ij)) {
                u_star[id] = 0.0;
                v_star[id] = 0.0;
                continue;
            }

            // Upwind advection
            double du_dx = (u_ij > 0.0)
                ? (u_ij - field.u(i, j - 1)) / grid.dx
                : (field.u(i, j + 1) - u_ij) / grid.dx;

            double du_dy = (v_ij > 0.0)
                ? (u_ij - field.u(i - 1, j)) / grid.dy
                : (field.u(i + 1, j) - u_ij) / grid.dy;

            double dv_dx = (u_ij > 0.0)
                ? (v_ij - field.v(i, j - 1)) / grid.dx
                : (field.v(i, j + 1) - v_ij) / grid.dx;

            double dv_dy = (v_ij > 0.0)
                ? (v_ij - field.v(i - 1, j)) / grid.dy
                : (field.v(i + 1, j) - v_ij) / grid.dy;

            // Diffusion
            double d2u_dx2 = (field.u(i, j + 1) - 2.0 * u_ij + field.u(i, j - 1)) / (grid.dx * grid.dx);
            double d2u_dy2 = (field.u(i + 1, j) - 2.0 * u_ij + field.u(i - 1, j)) / (grid.dy * grid.dy);

            double d2v_dx2 = (field.v(i, j + 1) - 2.0 * v_ij + field.v(i, j - 1)) / (grid.dx * grid.dx);
            double d2v_dy2 = (field.v(i + 1, j) - 2.0 * v_ij + field.v(i - 1, j)) / (grid.dy * grid.dy);

            // Explicit update
            double new_u = u_ij + dt * (-u_ij * du_dx - v_ij * du_dy + nu * (d2u_dx2 + d2u_dy2));
            double new_v = v_ij + dt * (-u_ij * dv_dx - v_ij * dv_dy + nu * (d2v_dx2 + d2v_dy2));
            
            // Clamp to prevent blow-up
            u_star[id] = std::isnan(new_u) ? 0.0 : std::clamp(new_u, -100.0, 100.0);
            v_star[id] = std::isnan(new_v) ? 0.0 : std::clamp(new_v, -100.0, 100.0);
        }
    }
}


//------------------- Step 2: Solve Pressure Poisson Equation -------------------
void Solver::solvePressurePoisson(int nit, double tol, double omega){
    const int nx = grid.nx;
    const int ny = grid.ny;

    int ref_i = std::clamp(ny / 2, 1, ny - 2);
    int ref_j = nx - 2;
    while (ref_j > 1 && !grid.isFluid(ref_i, ref_j)) {
        --ref_j;
    }

    const double dx2 = grid.dx * grid.dx;
    const double dy2 = grid.dy * grid.dy;
    const double coeff = 2.0 * (dx2 + dy2);

    int it;
    double finalResidual = 0.0;
    for (it = 0; it < nit; ++it) {
        double maxResidual = 0.0;

        for (int i = 1; i < ny - 1; ++i) {
            for (int j = 1; j < nx - 1; ++j) {
                if (!grid.isFluid(i, j)) {
                    field.p(i, j) = 0.25 * (field.p(i + 1, j) + field.p(i - 1, j) + field.p(i, j + 1) + field.p(i, j - 1));
                    continue;
                }

                double du_dx = (u_star[idx(i, j + 1)] - u_star[idx(i, j - 1)]) / (2.0 * grid.dx);
                double dv_dy = (v_star[idx(i + 1, j)] - v_star[idx(i - 1, j)]) / (2.0 * grid.dy);
                double rhs = rho / dt * (du_dx + dv_dy);

                double p_old = field.p(i, j);
                double p_gs = ((field.p(i, j + 1) + field.p(i, j - 1)) * dy2 +
                               (field.p(i + 1, j) + field.p(i - 1, j)) * dx2 -
                               rhs * dx2 * dy2) / coeff;

                double p_new = (1.0 - omega) * p_old + omega * p_gs;
                field.p(i, j) = p_new;
                maxResidual = std::max(maxResidual, std::abs(p_new - p_old));
            }
        }

        for (int j = 0; j < nx; ++j) {
            field.p(0, j) = field.p(1, j);
            field.p(ny - 1, j) = field.p(ny - 2, j);
        }

        for (int i = 0; i < ny; ++i) {
            field.p(i, 0) = field.p(i, 1);
            field.p(i, nx - 1) = field.p(i, nx - 2);
        }

        if (grid.isFluid(ref_i, ref_j)) {
            field.p(ref_i, ref_j) = 0.0;
        }

        finalResidual = maxResidual;
        if (maxResidual < tol) {
            break;
        }
    }
    
    static int callCount = 0;
    if (++callCount % 50 == 0) {
        std::cout << "Poisson iterations: " << (it + 1) << ", final residual: " << finalResidual << std::endl;
    }
}

//------------------- Step 3: Update Velocities -------------------
void Solver::correctVelocities(){
    #pragma omp parallel for schedule(static)
    for (int i = 1; i < grid.ny -1; i++){
        for (int j = 1; j< grid.nx -1; j++){
            if(!grid.isFluid(i,j)) continue; //Skip solid cells

            //Pressure gradient
            double dp_dx = (field.p(i, j+1) - field.p(i, j-1)) / (2 * grid.dx);
            double dp_dy = (field.p(i+1, j) - field.p(i-1, j)) / (2 * grid.dy);

            //Correct velocities
            size_t id = idx(i, j);
            field.u(i, j) = u_star[id] - dt / rho * dp_dx;
            field.v(i, j) = v_star[id] - dt / rho * dp_dy;
        }
    }
}

//------------------- Step 4: Single Time Step -------------------
void Solver::step(){
    computeIntermediateVelocities();
    solvePressurePoisson(50, 1e10, 1.7);
    correctVelocities();
}
